网络：

粘包：
TCP在接受数据的时候，有一个缓冲区。缓冲区满了就会把数据发送。数据包的大小是不固定的，有时候比缓冲区大有时候小。如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题

封包：
一条数据的最终形态 包头+包体（消息号Id、消息体）

需要知道每一条数据的长度才能解析这一条数据，才能把数据解析的完整且不报错

Canvas ： 当顶点改变或渲染材质改变就会重新绘制，调用Rebuild ；

防止Canvas一直重新绘制，就将Canvas分层，进行动静分离；

例如 万国觉醒中的UI的13层：
1. HUDLayer：通常用于显示游戏或应用中的关键信息，如生命值、得分等，这些信息通常悬浮在主视图之上。
2. FullViewLayer：可能用于显示需要全屏展示的内容，如视频播放、全屏游戏模式等。
3. FullViewMenuLayer：可能用于显示全屏菜单，例如游戏开始菜单或设置菜单，这些菜单通常覆盖整个屏幕。
4. ChatLayer：用于显示聊天界面，用户可以在这个层中进行交流。
5. StoryLayer：可能用于展示故事内容或剧情发展，常见于叙事驱动的游戏或应用中。
6. WindowLayer：可能用于显示各种窗口，如对话框、提示框等。
7. WindowMenuLayer：可能用于显示窗口菜单，例如右键菜单或窗口内的菜单选项。
8. WindowPopLayer：可能用于显示弹出窗口，如通知、警告或广告。
9. GuideLayer：通常用于引导玩家或用户了解游戏或应用的玩法和功能。
10. TipLayer：用于显示提示信息，帮助用户理解当前的操作或提供帮助。
11. SystemOpenLayer：可能用于显示系统打开的界面，如系统设置或系统信息。
12. LoadingLayer：用于显示加载动画或信息，告知用户内容正在加载中。
13. BrowserLayer：可能用于嵌入浏览器功能，允许用户在应用内浏览网页。

Canvas重建是UGUI最大的性能消耗

优化：
进行动静分离拆封Canvas；将频繁移动的放在动态的Canvas下，可以降低静态元素的更新频率
避免频繁的销毁和创建一个界面；
避免频繁的SetActive界面，可以将其放在Canvas外来不显示，也可以用CanvasGroup进行替代
当界面不显示时，该界面的一切周期函数如Updata一定停止运行