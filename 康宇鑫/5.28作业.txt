Canvas分层（万国Canvas分层）
* 在Canvas下当顶点改变和渲染材质改变就会重新进行绘制，防止一直重新绘制就将Canvas分层
在UIRoot的Container层中，各个层的作用如下：
1. HUDLayer：通常用于显示游戏或应用中的关键信息，如生命值、得分等，这些信息通常悬浮在主视图之上。
2. FullViewLayer：可能用于显示需要全屏展示的内容，如视频播放、全屏游戏模式等。
3. FullViewMenuLayer：可能用于显示全屏菜单，例如游戏开始菜单或设置菜单，这些菜单通常覆盖整个屏幕。
4. ChatLayer：用于显示聊天界面，用户可以在这个层中进行交流。
5. StoryLayer：可能用于展示故事内容或剧情发展，常见于叙事驱动的游戏或应用中。
6. WindowLayer：可能用于显示各种窗口，如对话框、提示框等。
7. WindowMenuLayer：可能用于显示窗口菜单，例如右键菜单或窗口内的菜单选项。
8. WindowPopLayer：可能用于显示弹出窗口，如通知、警告或广告。
9. GuideLayer：通常用于引导玩家或用户了解游戏或应用的玩法和功能。
10. TipLayer：用于显示提示信息，帮助用户理解当前的操作或提供帮助。
11. SystemOpenLayer：可能用于显示系统打开的界面，如系统设置或系统信息。
12. LoadingLayer：用于显示加载动画或信息，告知用户内容正在加载中。
13. BrowserLayer：可能用于嵌入浏览器功能，允许用户在应用内浏览网页。
这些层级结构有助于组织和管理UI元素，使得界面布局更加清晰和有序。

Canvas优化要点：
优化方法：
（1）一个Canvas下的所有UI元素都是合在一个Mesh中的，过大的Mesh在更新时开销很大，一般建议每个较为复杂的UI界面，都创建一个Canvas（可以是子Canvas）,在UI界面很复杂时，甚至要划分更多的子Canvas，而Canvas又不能细分的太多，因为会导致DrawCall的上升；

（2）动静分离（将静态 UI 元素（如背景图、固定按钮）和动态 UI 元素（如血条、动画特效）分别放置在不同的 Canvas 中。这样可以减少因动态元素更新而导致整个 Canvas 重绘的开销）

（3）把一个面板的UI资源放到一个图集里；

（4）CanvasGroup 控制：使用 CanvasGroup 控制局部透明度或启用/禁用，避免影响其他层

粘包
需要知道每一条数据的长度
粘包是指在网络通信中，发送端发送的多个数据包在接收端被错误地合并为一个数据包
发生粘包的原因：
1. TCP是面向流的协议（ TCP协议将数据视为一个连续的字节流，不保留消息边界。发送端发送的多个数据可能会被接收端合并接收，或者一个较大的数据包可能会被分割成多个小包）
2. 网络延迟和拥塞（ 网络中的延迟和拥塞可能导致数据包的分段和重组）
解决方法：
1. 使用分隔符（ 在每个数据包的末尾添加一个特殊的分隔符（如换行符、特定的字节序列等），接收端通过分隔符来区分不同的数据包）
2. 固定长度数据包（ 约定每个数据包的长度是固定的，接收端根据固定长度来拆分数据包）
3. 长度字段（ 在每个数据包的头部添加一个长度字段，接收端根据长度字段来确定每个数据包的边界）
4. 协议层拆包（ 在应用层或传输层实现自己的拆包机制，通过协议规定来确保数据包的正确拆分）


拆包（发生在接收端）
拆包是指接收端将接收到的网络数据包按照协议格式进行解封装，以还原出原始数据
* 目的：将经过封装的数据包逐层解包，提取出应用层需要的原始数据
* 作用：
    * 还原数据：将网络数据包中的头部信息剥离，提取出原始数据
    * 验证数据完整性：通过校验码等机制，检查数据在传输过程中是否被篡改或损坏
    * 分发数据：将数据按照协议层次逐层向上传递，最终到达应用层
分片（发生在放松段或网络中间节点—路由器）
* 定义：是发送端或网络中间节点将较大的数据包拆分成多个较小的数据包，以适应网络传输限制的过程
* 目的：为了适应网络链路的最大传输单元（MTU）限制，或者为了满足某些协议的要求


封包
一条网络数据的最终型态
封包是指将数据按照一定的协议格式进行封装，以便在网络中传输
* 作用：
    * 标准化数据格式：将数据按照协议要求进行格式化，例如添加头部信息（如源地址、目的地址、协议类型、数据长度等）
    * 确保数据完整性：通过添加校验码等机制，确保数据在传输过程中能够被正确接收和验证
    * 提高传输效率：将数据分割成合适大小的片段（数据包），以便在网络中高效传输